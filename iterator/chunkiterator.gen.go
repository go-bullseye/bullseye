// Code generated by iterator/chunkiterator.gen.go.tmpl. DO NOT EDIT.

package iterator

import (
	"sync/atomic"

	"github.com/apache/arrow/go/arrow"
	"github.com/apache/arrow/go/arrow/array"
	"github.com/apache/arrow/go/arrow/float16"
	"github.com/go-bullseye/bullseye/internal/debug"
)

// Int64ChunkIterator is an iterator for reading an Arrow Column value by value.
type Int64ChunkIterator struct {
	refCount int64
	col      *array.Column

	// Things Chunked maintains. We're going to maintain it ourselves.
	chunks []*array.Int64 // cache the chunks on this iterator
	length int64          // this isn't set right on Chunked so we won't rely on it there. Instead we keep the correct value here.
	nulls  int64
	dtype  arrow.DataType

	// Things we need to maintain for the iterator
	currentIndex int          // current chunk
	currentChunk *array.Int64 // current chunk
}

// NewInt64ChunkIterator creates a new Int64ChunkIterator for reading an Arrow Column.
func NewInt64ChunkIterator(col *array.Column) *Int64ChunkIterator {
	col.Retain()

	// Chunked is not using the correct type to keep track of length so we have to recalculate it.
	columnChunks := col.Data().Chunks()
	chunks := make([]*array.Int64, len(columnChunks))
	var length int64
	var nulls int64

	for i, chunk := range columnChunks {
		// Keep our own refs to chunks
		chunks[i] = chunk.(*array.Int64)
		// Retain the chunk
		chunks[i].Retain()

		// Keep our own counters instead of Chunked's
		length += int64(chunk.Len())
		nulls += int64(chunk.NullN())
	}

	return &Int64ChunkIterator{
		refCount: 1,
		col:      col,

		chunks: chunks,
		length: length,
		nulls:  nulls,
		dtype:  col.DataType(),

		currentIndex: 0,
		currentChunk: nil,
	}
}

// Chunk will return the current chunk that the iterator is on.
func (cr *Int64ChunkIterator) Chunk() *array.Int64 { return cr.currentChunk }

// ChunkValues returns the underlying []int64 chunk values.
// Keep in mind the []int64 type might not be able
// to account for nil values. You must check for those explicitly via the chunk.
func (cr *Int64ChunkIterator) ChunkValues() []int64 { return cr.Chunk().Int64Values() }

// Next moves the iterator to the next chunk. This will return false
// when there are no more chunks.
func (cr *Int64ChunkIterator) Next() bool {
	if cr.currentIndex >= len(cr.chunks) {
		return false
	}

	if cr.currentChunk != nil {
		cr.currentChunk.Release()
	}

	cr.currentChunk = cr.chunks[cr.currentIndex]
	cr.currentChunk.Retain()
	cr.currentIndex++

	return true
}

// Retain keeps a reference to the Int64ChunkIterator
func (cr *Int64ChunkIterator) Retain() {
	atomic.AddInt64(&cr.refCount, 1)
}

// Release removes a reference to the Int64ChunkIterator
func (cr *Int64ChunkIterator) Release() {
	debug.Assert(atomic.LoadInt64(&cr.refCount) > 0, "too many releases")
	ref := atomic.AddInt64(&cr.refCount, -1)
	if ref == 0 {
		cr.col.Release()
		for i := range cr.chunks {
			cr.chunks[i].Release()
		}
		if cr.currentChunk != nil {
			cr.currentChunk.Release()
			cr.currentChunk = nil
		}
		cr.col = nil
		cr.chunks = nil
		cr.dtype = nil
	}
}

// Uint64ChunkIterator is an iterator for reading an Arrow Column value by value.
type Uint64ChunkIterator struct {
	refCount int64
	col      *array.Column

	// Things Chunked maintains. We're going to maintain it ourselves.
	chunks []*array.Uint64 // cache the chunks on this iterator
	length int64           // this isn't set right on Chunked so we won't rely on it there. Instead we keep the correct value here.
	nulls  int64
	dtype  arrow.DataType

	// Things we need to maintain for the iterator
	currentIndex int           // current chunk
	currentChunk *array.Uint64 // current chunk
}

// NewUint64ChunkIterator creates a new Uint64ChunkIterator for reading an Arrow Column.
func NewUint64ChunkIterator(col *array.Column) *Uint64ChunkIterator {
	col.Retain()

	// Chunked is not using the correct type to keep track of length so we have to recalculate it.
	columnChunks := col.Data().Chunks()
	chunks := make([]*array.Uint64, len(columnChunks))
	var length int64
	var nulls int64

	for i, chunk := range columnChunks {
		// Keep our own refs to chunks
		chunks[i] = chunk.(*array.Uint64)
		// Retain the chunk
		chunks[i].Retain()

		// Keep our own counters instead of Chunked's
		length += int64(chunk.Len())
		nulls += int64(chunk.NullN())
	}

	return &Uint64ChunkIterator{
		refCount: 1,
		col:      col,

		chunks: chunks,
		length: length,
		nulls:  nulls,
		dtype:  col.DataType(),

		currentIndex: 0,
		currentChunk: nil,
	}
}

// Chunk will return the current chunk that the iterator is on.
func (cr *Uint64ChunkIterator) Chunk() *array.Uint64 { return cr.currentChunk }

// ChunkValues returns the underlying []uint64 chunk values.
// Keep in mind the []uint64 type might not be able
// to account for nil values. You must check for those explicitly via the chunk.
func (cr *Uint64ChunkIterator) ChunkValues() []uint64 { return cr.Chunk().Uint64Values() }

// Next moves the iterator to the next chunk. This will return false
// when there are no more chunks.
func (cr *Uint64ChunkIterator) Next() bool {
	if cr.currentIndex >= len(cr.chunks) {
		return false
	}

	if cr.currentChunk != nil {
		cr.currentChunk.Release()
	}

	cr.currentChunk = cr.chunks[cr.currentIndex]
	cr.currentChunk.Retain()
	cr.currentIndex++

	return true
}

// Retain keeps a reference to the Uint64ChunkIterator
func (cr *Uint64ChunkIterator) Retain() {
	atomic.AddInt64(&cr.refCount, 1)
}

// Release removes a reference to the Uint64ChunkIterator
func (cr *Uint64ChunkIterator) Release() {
	debug.Assert(atomic.LoadInt64(&cr.refCount) > 0, "too many releases")
	ref := atomic.AddInt64(&cr.refCount, -1)
	if ref == 0 {
		cr.col.Release()
		for i := range cr.chunks {
			cr.chunks[i].Release()
		}
		if cr.currentChunk != nil {
			cr.currentChunk.Release()
			cr.currentChunk = nil
		}
		cr.col = nil
		cr.chunks = nil
		cr.dtype = nil
	}
}

// Float64ChunkIterator is an iterator for reading an Arrow Column value by value.
type Float64ChunkIterator struct {
	refCount int64
	col      *array.Column

	// Things Chunked maintains. We're going to maintain it ourselves.
	chunks []*array.Float64 // cache the chunks on this iterator
	length int64            // this isn't set right on Chunked so we won't rely on it there. Instead we keep the correct value here.
	nulls  int64
	dtype  arrow.DataType

	// Things we need to maintain for the iterator
	currentIndex int            // current chunk
	currentChunk *array.Float64 // current chunk
}

// NewFloat64ChunkIterator creates a new Float64ChunkIterator for reading an Arrow Column.
func NewFloat64ChunkIterator(col *array.Column) *Float64ChunkIterator {
	col.Retain()

	// Chunked is not using the correct type to keep track of length so we have to recalculate it.
	columnChunks := col.Data().Chunks()
	chunks := make([]*array.Float64, len(columnChunks))
	var length int64
	var nulls int64

	for i, chunk := range columnChunks {
		// Keep our own refs to chunks
		chunks[i] = chunk.(*array.Float64)
		// Retain the chunk
		chunks[i].Retain()

		// Keep our own counters instead of Chunked's
		length += int64(chunk.Len())
		nulls += int64(chunk.NullN())
	}

	return &Float64ChunkIterator{
		refCount: 1,
		col:      col,

		chunks: chunks,
		length: length,
		nulls:  nulls,
		dtype:  col.DataType(),

		currentIndex: 0,
		currentChunk: nil,
	}
}

// Chunk will return the current chunk that the iterator is on.
func (cr *Float64ChunkIterator) Chunk() *array.Float64 { return cr.currentChunk }

// ChunkValues returns the underlying []float64 chunk values.
// Keep in mind the []float64 type might not be able
// to account for nil values. You must check for those explicitly via the chunk.
func (cr *Float64ChunkIterator) ChunkValues() []float64 { return cr.Chunk().Float64Values() }

// Next moves the iterator to the next chunk. This will return false
// when there are no more chunks.
func (cr *Float64ChunkIterator) Next() bool {
	if cr.currentIndex >= len(cr.chunks) {
		return false
	}

	if cr.currentChunk != nil {
		cr.currentChunk.Release()
	}

	cr.currentChunk = cr.chunks[cr.currentIndex]
	cr.currentChunk.Retain()
	cr.currentIndex++

	return true
}

// Retain keeps a reference to the Float64ChunkIterator
func (cr *Float64ChunkIterator) Retain() {
	atomic.AddInt64(&cr.refCount, 1)
}

// Release removes a reference to the Float64ChunkIterator
func (cr *Float64ChunkIterator) Release() {
	debug.Assert(atomic.LoadInt64(&cr.refCount) > 0, "too many releases")
	ref := atomic.AddInt64(&cr.refCount, -1)
	if ref == 0 {
		cr.col.Release()
		for i := range cr.chunks {
			cr.chunks[i].Release()
		}
		if cr.currentChunk != nil {
			cr.currentChunk.Release()
			cr.currentChunk = nil
		}
		cr.col = nil
		cr.chunks = nil
		cr.dtype = nil
	}
}

// Int32ChunkIterator is an iterator for reading an Arrow Column value by value.
type Int32ChunkIterator struct {
	refCount int64
	col      *array.Column

	// Things Chunked maintains. We're going to maintain it ourselves.
	chunks []*array.Int32 // cache the chunks on this iterator
	length int64          // this isn't set right on Chunked so we won't rely on it there. Instead we keep the correct value here.
	nulls  int64
	dtype  arrow.DataType

	// Things we need to maintain for the iterator
	currentIndex int          // current chunk
	currentChunk *array.Int32 // current chunk
}

// NewInt32ChunkIterator creates a new Int32ChunkIterator for reading an Arrow Column.
func NewInt32ChunkIterator(col *array.Column) *Int32ChunkIterator {
	col.Retain()

	// Chunked is not using the correct type to keep track of length so we have to recalculate it.
	columnChunks := col.Data().Chunks()
	chunks := make([]*array.Int32, len(columnChunks))
	var length int64
	var nulls int64

	for i, chunk := range columnChunks {
		// Keep our own refs to chunks
		chunks[i] = chunk.(*array.Int32)
		// Retain the chunk
		chunks[i].Retain()

		// Keep our own counters instead of Chunked's
		length += int64(chunk.Len())
		nulls += int64(chunk.NullN())
	}

	return &Int32ChunkIterator{
		refCount: 1,
		col:      col,

		chunks: chunks,
		length: length,
		nulls:  nulls,
		dtype:  col.DataType(),

		currentIndex: 0,
		currentChunk: nil,
	}
}

// Chunk will return the current chunk that the iterator is on.
func (cr *Int32ChunkIterator) Chunk() *array.Int32 { return cr.currentChunk }

// ChunkValues returns the underlying []int32 chunk values.
// Keep in mind the []int32 type might not be able
// to account for nil values. You must check for those explicitly via the chunk.
func (cr *Int32ChunkIterator) ChunkValues() []int32 { return cr.Chunk().Int32Values() }

// Next moves the iterator to the next chunk. This will return false
// when there are no more chunks.
func (cr *Int32ChunkIterator) Next() bool {
	if cr.currentIndex >= len(cr.chunks) {
		return false
	}

	if cr.currentChunk != nil {
		cr.currentChunk.Release()
	}

	cr.currentChunk = cr.chunks[cr.currentIndex]
	cr.currentChunk.Retain()
	cr.currentIndex++

	return true
}

// Retain keeps a reference to the Int32ChunkIterator
func (cr *Int32ChunkIterator) Retain() {
	atomic.AddInt64(&cr.refCount, 1)
}

// Release removes a reference to the Int32ChunkIterator
func (cr *Int32ChunkIterator) Release() {
	debug.Assert(atomic.LoadInt64(&cr.refCount) > 0, "too many releases")
	ref := atomic.AddInt64(&cr.refCount, -1)
	if ref == 0 {
		cr.col.Release()
		for i := range cr.chunks {
			cr.chunks[i].Release()
		}
		if cr.currentChunk != nil {
			cr.currentChunk.Release()
			cr.currentChunk = nil
		}
		cr.col = nil
		cr.chunks = nil
		cr.dtype = nil
	}
}

// Uint32ChunkIterator is an iterator for reading an Arrow Column value by value.
type Uint32ChunkIterator struct {
	refCount int64
	col      *array.Column

	// Things Chunked maintains. We're going to maintain it ourselves.
	chunks []*array.Uint32 // cache the chunks on this iterator
	length int64           // this isn't set right on Chunked so we won't rely on it there. Instead we keep the correct value here.
	nulls  int64
	dtype  arrow.DataType

	// Things we need to maintain for the iterator
	currentIndex int           // current chunk
	currentChunk *array.Uint32 // current chunk
}

// NewUint32ChunkIterator creates a new Uint32ChunkIterator for reading an Arrow Column.
func NewUint32ChunkIterator(col *array.Column) *Uint32ChunkIterator {
	col.Retain()

	// Chunked is not using the correct type to keep track of length so we have to recalculate it.
	columnChunks := col.Data().Chunks()
	chunks := make([]*array.Uint32, len(columnChunks))
	var length int64
	var nulls int64

	for i, chunk := range columnChunks {
		// Keep our own refs to chunks
		chunks[i] = chunk.(*array.Uint32)
		// Retain the chunk
		chunks[i].Retain()

		// Keep our own counters instead of Chunked's
		length += int64(chunk.Len())
		nulls += int64(chunk.NullN())
	}

	return &Uint32ChunkIterator{
		refCount: 1,
		col:      col,

		chunks: chunks,
		length: length,
		nulls:  nulls,
		dtype:  col.DataType(),

		currentIndex: 0,
		currentChunk: nil,
	}
}

// Chunk will return the current chunk that the iterator is on.
func (cr *Uint32ChunkIterator) Chunk() *array.Uint32 { return cr.currentChunk }

// ChunkValues returns the underlying []uint32 chunk values.
// Keep in mind the []uint32 type might not be able
// to account for nil values. You must check for those explicitly via the chunk.
func (cr *Uint32ChunkIterator) ChunkValues() []uint32 { return cr.Chunk().Uint32Values() }

// Next moves the iterator to the next chunk. This will return false
// when there are no more chunks.
func (cr *Uint32ChunkIterator) Next() bool {
	if cr.currentIndex >= len(cr.chunks) {
		return false
	}

	if cr.currentChunk != nil {
		cr.currentChunk.Release()
	}

	cr.currentChunk = cr.chunks[cr.currentIndex]
	cr.currentChunk.Retain()
	cr.currentIndex++

	return true
}

// Retain keeps a reference to the Uint32ChunkIterator
func (cr *Uint32ChunkIterator) Retain() {
	atomic.AddInt64(&cr.refCount, 1)
}

// Release removes a reference to the Uint32ChunkIterator
func (cr *Uint32ChunkIterator) Release() {
	debug.Assert(atomic.LoadInt64(&cr.refCount) > 0, "too many releases")
	ref := atomic.AddInt64(&cr.refCount, -1)
	if ref == 0 {
		cr.col.Release()
		for i := range cr.chunks {
			cr.chunks[i].Release()
		}
		if cr.currentChunk != nil {
			cr.currentChunk.Release()
			cr.currentChunk = nil
		}
		cr.col = nil
		cr.chunks = nil
		cr.dtype = nil
	}
}

// Float32ChunkIterator is an iterator for reading an Arrow Column value by value.
type Float32ChunkIterator struct {
	refCount int64
	col      *array.Column

	// Things Chunked maintains. We're going to maintain it ourselves.
	chunks []*array.Float32 // cache the chunks on this iterator
	length int64            // this isn't set right on Chunked so we won't rely on it there. Instead we keep the correct value here.
	nulls  int64
	dtype  arrow.DataType

	// Things we need to maintain for the iterator
	currentIndex int            // current chunk
	currentChunk *array.Float32 // current chunk
}

// NewFloat32ChunkIterator creates a new Float32ChunkIterator for reading an Arrow Column.
func NewFloat32ChunkIterator(col *array.Column) *Float32ChunkIterator {
	col.Retain()

	// Chunked is not using the correct type to keep track of length so we have to recalculate it.
	columnChunks := col.Data().Chunks()
	chunks := make([]*array.Float32, len(columnChunks))
	var length int64
	var nulls int64

	for i, chunk := range columnChunks {
		// Keep our own refs to chunks
		chunks[i] = chunk.(*array.Float32)
		// Retain the chunk
		chunks[i].Retain()

		// Keep our own counters instead of Chunked's
		length += int64(chunk.Len())
		nulls += int64(chunk.NullN())
	}

	return &Float32ChunkIterator{
		refCount: 1,
		col:      col,

		chunks: chunks,
		length: length,
		nulls:  nulls,
		dtype:  col.DataType(),

		currentIndex: 0,
		currentChunk: nil,
	}
}

// Chunk will return the current chunk that the iterator is on.
func (cr *Float32ChunkIterator) Chunk() *array.Float32 { return cr.currentChunk }

// ChunkValues returns the underlying []float32 chunk values.
// Keep in mind the []float32 type might not be able
// to account for nil values. You must check for those explicitly via the chunk.
func (cr *Float32ChunkIterator) ChunkValues() []float32 { return cr.Chunk().Float32Values() }

// Next moves the iterator to the next chunk. This will return false
// when there are no more chunks.
func (cr *Float32ChunkIterator) Next() bool {
	if cr.currentIndex >= len(cr.chunks) {
		return false
	}

	if cr.currentChunk != nil {
		cr.currentChunk.Release()
	}

	cr.currentChunk = cr.chunks[cr.currentIndex]
	cr.currentChunk.Retain()
	cr.currentIndex++

	return true
}

// Retain keeps a reference to the Float32ChunkIterator
func (cr *Float32ChunkIterator) Retain() {
	atomic.AddInt64(&cr.refCount, 1)
}

// Release removes a reference to the Float32ChunkIterator
func (cr *Float32ChunkIterator) Release() {
	debug.Assert(atomic.LoadInt64(&cr.refCount) > 0, "too many releases")
	ref := atomic.AddInt64(&cr.refCount, -1)
	if ref == 0 {
		cr.col.Release()
		for i := range cr.chunks {
			cr.chunks[i].Release()
		}
		if cr.currentChunk != nil {
			cr.currentChunk.Release()
			cr.currentChunk = nil
		}
		cr.col = nil
		cr.chunks = nil
		cr.dtype = nil
	}
}

// Int16ChunkIterator is an iterator for reading an Arrow Column value by value.
type Int16ChunkIterator struct {
	refCount int64
	col      *array.Column

	// Things Chunked maintains. We're going to maintain it ourselves.
	chunks []*array.Int16 // cache the chunks on this iterator
	length int64          // this isn't set right on Chunked so we won't rely on it there. Instead we keep the correct value here.
	nulls  int64
	dtype  arrow.DataType

	// Things we need to maintain for the iterator
	currentIndex int          // current chunk
	currentChunk *array.Int16 // current chunk
}

// NewInt16ChunkIterator creates a new Int16ChunkIterator for reading an Arrow Column.
func NewInt16ChunkIterator(col *array.Column) *Int16ChunkIterator {
	col.Retain()

	// Chunked is not using the correct type to keep track of length so we have to recalculate it.
	columnChunks := col.Data().Chunks()
	chunks := make([]*array.Int16, len(columnChunks))
	var length int64
	var nulls int64

	for i, chunk := range columnChunks {
		// Keep our own refs to chunks
		chunks[i] = chunk.(*array.Int16)
		// Retain the chunk
		chunks[i].Retain()

		// Keep our own counters instead of Chunked's
		length += int64(chunk.Len())
		nulls += int64(chunk.NullN())
	}

	return &Int16ChunkIterator{
		refCount: 1,
		col:      col,

		chunks: chunks,
		length: length,
		nulls:  nulls,
		dtype:  col.DataType(),

		currentIndex: 0,
		currentChunk: nil,
	}
}

// Chunk will return the current chunk that the iterator is on.
func (cr *Int16ChunkIterator) Chunk() *array.Int16 { return cr.currentChunk }

// ChunkValues returns the underlying []int16 chunk values.
// Keep in mind the []int16 type might not be able
// to account for nil values. You must check for those explicitly via the chunk.
func (cr *Int16ChunkIterator) ChunkValues() []int16 { return cr.Chunk().Int16Values() }

// Next moves the iterator to the next chunk. This will return false
// when there are no more chunks.
func (cr *Int16ChunkIterator) Next() bool {
	if cr.currentIndex >= len(cr.chunks) {
		return false
	}

	if cr.currentChunk != nil {
		cr.currentChunk.Release()
	}

	cr.currentChunk = cr.chunks[cr.currentIndex]
	cr.currentChunk.Retain()
	cr.currentIndex++

	return true
}

// Retain keeps a reference to the Int16ChunkIterator
func (cr *Int16ChunkIterator) Retain() {
	atomic.AddInt64(&cr.refCount, 1)
}

// Release removes a reference to the Int16ChunkIterator
func (cr *Int16ChunkIterator) Release() {
	debug.Assert(atomic.LoadInt64(&cr.refCount) > 0, "too many releases")
	ref := atomic.AddInt64(&cr.refCount, -1)
	if ref == 0 {
		cr.col.Release()
		for i := range cr.chunks {
			cr.chunks[i].Release()
		}
		if cr.currentChunk != nil {
			cr.currentChunk.Release()
			cr.currentChunk = nil
		}
		cr.col = nil
		cr.chunks = nil
		cr.dtype = nil
	}
}

// Uint16ChunkIterator is an iterator for reading an Arrow Column value by value.
type Uint16ChunkIterator struct {
	refCount int64
	col      *array.Column

	// Things Chunked maintains. We're going to maintain it ourselves.
	chunks []*array.Uint16 // cache the chunks on this iterator
	length int64           // this isn't set right on Chunked so we won't rely on it there. Instead we keep the correct value here.
	nulls  int64
	dtype  arrow.DataType

	// Things we need to maintain for the iterator
	currentIndex int           // current chunk
	currentChunk *array.Uint16 // current chunk
}

// NewUint16ChunkIterator creates a new Uint16ChunkIterator for reading an Arrow Column.
func NewUint16ChunkIterator(col *array.Column) *Uint16ChunkIterator {
	col.Retain()

	// Chunked is not using the correct type to keep track of length so we have to recalculate it.
	columnChunks := col.Data().Chunks()
	chunks := make([]*array.Uint16, len(columnChunks))
	var length int64
	var nulls int64

	for i, chunk := range columnChunks {
		// Keep our own refs to chunks
		chunks[i] = chunk.(*array.Uint16)
		// Retain the chunk
		chunks[i].Retain()

		// Keep our own counters instead of Chunked's
		length += int64(chunk.Len())
		nulls += int64(chunk.NullN())
	}

	return &Uint16ChunkIterator{
		refCount: 1,
		col:      col,

		chunks: chunks,
		length: length,
		nulls:  nulls,
		dtype:  col.DataType(),

		currentIndex: 0,
		currentChunk: nil,
	}
}

// Chunk will return the current chunk that the iterator is on.
func (cr *Uint16ChunkIterator) Chunk() *array.Uint16 { return cr.currentChunk }

// ChunkValues returns the underlying []uint16 chunk values.
// Keep in mind the []uint16 type might not be able
// to account for nil values. You must check for those explicitly via the chunk.
func (cr *Uint16ChunkIterator) ChunkValues() []uint16 { return cr.Chunk().Uint16Values() }

// Next moves the iterator to the next chunk. This will return false
// when there are no more chunks.
func (cr *Uint16ChunkIterator) Next() bool {
	if cr.currentIndex >= len(cr.chunks) {
		return false
	}

	if cr.currentChunk != nil {
		cr.currentChunk.Release()
	}

	cr.currentChunk = cr.chunks[cr.currentIndex]
	cr.currentChunk.Retain()
	cr.currentIndex++

	return true
}

// Retain keeps a reference to the Uint16ChunkIterator
func (cr *Uint16ChunkIterator) Retain() {
	atomic.AddInt64(&cr.refCount, 1)
}

// Release removes a reference to the Uint16ChunkIterator
func (cr *Uint16ChunkIterator) Release() {
	debug.Assert(atomic.LoadInt64(&cr.refCount) > 0, "too many releases")
	ref := atomic.AddInt64(&cr.refCount, -1)
	if ref == 0 {
		cr.col.Release()
		for i := range cr.chunks {
			cr.chunks[i].Release()
		}
		if cr.currentChunk != nil {
			cr.currentChunk.Release()
			cr.currentChunk = nil
		}
		cr.col = nil
		cr.chunks = nil
		cr.dtype = nil
	}
}

// Int8ChunkIterator is an iterator for reading an Arrow Column value by value.
type Int8ChunkIterator struct {
	refCount int64
	col      *array.Column

	// Things Chunked maintains. We're going to maintain it ourselves.
	chunks []*array.Int8 // cache the chunks on this iterator
	length int64         // this isn't set right on Chunked so we won't rely on it there. Instead we keep the correct value here.
	nulls  int64
	dtype  arrow.DataType

	// Things we need to maintain for the iterator
	currentIndex int         // current chunk
	currentChunk *array.Int8 // current chunk
}

// NewInt8ChunkIterator creates a new Int8ChunkIterator for reading an Arrow Column.
func NewInt8ChunkIterator(col *array.Column) *Int8ChunkIterator {
	col.Retain()

	// Chunked is not using the correct type to keep track of length so we have to recalculate it.
	columnChunks := col.Data().Chunks()
	chunks := make([]*array.Int8, len(columnChunks))
	var length int64
	var nulls int64

	for i, chunk := range columnChunks {
		// Keep our own refs to chunks
		chunks[i] = chunk.(*array.Int8)
		// Retain the chunk
		chunks[i].Retain()

		// Keep our own counters instead of Chunked's
		length += int64(chunk.Len())
		nulls += int64(chunk.NullN())
	}

	return &Int8ChunkIterator{
		refCount: 1,
		col:      col,

		chunks: chunks,
		length: length,
		nulls:  nulls,
		dtype:  col.DataType(),

		currentIndex: 0,
		currentChunk: nil,
	}
}

// Chunk will return the current chunk that the iterator is on.
func (cr *Int8ChunkIterator) Chunk() *array.Int8 { return cr.currentChunk }

// ChunkValues returns the underlying []int8 chunk values.
// Keep in mind the []int8 type might not be able
// to account for nil values. You must check for those explicitly via the chunk.
func (cr *Int8ChunkIterator) ChunkValues() []int8 { return cr.Chunk().Int8Values() }

// Next moves the iterator to the next chunk. This will return false
// when there are no more chunks.
func (cr *Int8ChunkIterator) Next() bool {
	if cr.currentIndex >= len(cr.chunks) {
		return false
	}

	if cr.currentChunk != nil {
		cr.currentChunk.Release()
	}

	cr.currentChunk = cr.chunks[cr.currentIndex]
	cr.currentChunk.Retain()
	cr.currentIndex++

	return true
}

// Retain keeps a reference to the Int8ChunkIterator
func (cr *Int8ChunkIterator) Retain() {
	atomic.AddInt64(&cr.refCount, 1)
}

// Release removes a reference to the Int8ChunkIterator
func (cr *Int8ChunkIterator) Release() {
	debug.Assert(atomic.LoadInt64(&cr.refCount) > 0, "too many releases")
	ref := atomic.AddInt64(&cr.refCount, -1)
	if ref == 0 {
		cr.col.Release()
		for i := range cr.chunks {
			cr.chunks[i].Release()
		}
		if cr.currentChunk != nil {
			cr.currentChunk.Release()
			cr.currentChunk = nil
		}
		cr.col = nil
		cr.chunks = nil
		cr.dtype = nil
	}
}

// Uint8ChunkIterator is an iterator for reading an Arrow Column value by value.
type Uint8ChunkIterator struct {
	refCount int64
	col      *array.Column

	// Things Chunked maintains. We're going to maintain it ourselves.
	chunks []*array.Uint8 // cache the chunks on this iterator
	length int64          // this isn't set right on Chunked so we won't rely on it there. Instead we keep the correct value here.
	nulls  int64
	dtype  arrow.DataType

	// Things we need to maintain for the iterator
	currentIndex int          // current chunk
	currentChunk *array.Uint8 // current chunk
}

// NewUint8ChunkIterator creates a new Uint8ChunkIterator for reading an Arrow Column.
func NewUint8ChunkIterator(col *array.Column) *Uint8ChunkIterator {
	col.Retain()

	// Chunked is not using the correct type to keep track of length so we have to recalculate it.
	columnChunks := col.Data().Chunks()
	chunks := make([]*array.Uint8, len(columnChunks))
	var length int64
	var nulls int64

	for i, chunk := range columnChunks {
		// Keep our own refs to chunks
		chunks[i] = chunk.(*array.Uint8)
		// Retain the chunk
		chunks[i].Retain()

		// Keep our own counters instead of Chunked's
		length += int64(chunk.Len())
		nulls += int64(chunk.NullN())
	}

	return &Uint8ChunkIterator{
		refCount: 1,
		col:      col,

		chunks: chunks,
		length: length,
		nulls:  nulls,
		dtype:  col.DataType(),

		currentIndex: 0,
		currentChunk: nil,
	}
}

// Chunk will return the current chunk that the iterator is on.
func (cr *Uint8ChunkIterator) Chunk() *array.Uint8 { return cr.currentChunk }

// ChunkValues returns the underlying []uint8 chunk values.
// Keep in mind the []uint8 type might not be able
// to account for nil values. You must check for those explicitly via the chunk.
func (cr *Uint8ChunkIterator) ChunkValues() []uint8 { return cr.Chunk().Uint8Values() }

// Next moves the iterator to the next chunk. This will return false
// when there are no more chunks.
func (cr *Uint8ChunkIterator) Next() bool {
	if cr.currentIndex >= len(cr.chunks) {
		return false
	}

	if cr.currentChunk != nil {
		cr.currentChunk.Release()
	}

	cr.currentChunk = cr.chunks[cr.currentIndex]
	cr.currentChunk.Retain()
	cr.currentIndex++

	return true
}

// Retain keeps a reference to the Uint8ChunkIterator
func (cr *Uint8ChunkIterator) Retain() {
	atomic.AddInt64(&cr.refCount, 1)
}

// Release removes a reference to the Uint8ChunkIterator
func (cr *Uint8ChunkIterator) Release() {
	debug.Assert(atomic.LoadInt64(&cr.refCount) > 0, "too many releases")
	ref := atomic.AddInt64(&cr.refCount, -1)
	if ref == 0 {
		cr.col.Release()
		for i := range cr.chunks {
			cr.chunks[i].Release()
		}
		if cr.currentChunk != nil {
			cr.currentChunk.Release()
			cr.currentChunk = nil
		}
		cr.col = nil
		cr.chunks = nil
		cr.dtype = nil
	}
}

// Float16ChunkIterator is an iterator for reading an Arrow Column value by value.
type Float16ChunkIterator struct {
	refCount int64
	col      *array.Column

	// Things Chunked maintains. We're going to maintain it ourselves.
	chunks []*array.Float16 // cache the chunks on this iterator
	length int64            // this isn't set right on Chunked so we won't rely on it there. Instead we keep the correct value here.
	nulls  int64
	dtype  arrow.DataType

	// Things we need to maintain for the iterator
	currentIndex int            // current chunk
	currentChunk *array.Float16 // current chunk
}

// NewFloat16ChunkIterator creates a new Float16ChunkIterator for reading an Arrow Column.
func NewFloat16ChunkIterator(col *array.Column) *Float16ChunkIterator {
	col.Retain()

	// Chunked is not using the correct type to keep track of length so we have to recalculate it.
	columnChunks := col.Data().Chunks()
	chunks := make([]*array.Float16, len(columnChunks))
	var length int64
	var nulls int64

	for i, chunk := range columnChunks {
		// Keep our own refs to chunks
		chunks[i] = chunk.(*array.Float16)
		// Retain the chunk
		chunks[i].Retain()

		// Keep our own counters instead of Chunked's
		length += int64(chunk.Len())
		nulls += int64(chunk.NullN())
	}

	return &Float16ChunkIterator{
		refCount: 1,
		col:      col,

		chunks: chunks,
		length: length,
		nulls:  nulls,
		dtype:  col.DataType(),

		currentIndex: 0,
		currentChunk: nil,
	}
}

// Chunk will return the current chunk that the iterator is on.
func (cr *Float16ChunkIterator) Chunk() *array.Float16 { return cr.currentChunk }

// ChunkValues returns the underlying []float16.Num chunk values.
// Keep in mind the []float16.Num type might not be able
// to account for nil values. You must check for those explicitly via the chunk.
func (cr *Float16ChunkIterator) ChunkValues() []float16.Num { return cr.Chunk().Values() }

// Next moves the iterator to the next chunk. This will return false
// when there are no more chunks.
func (cr *Float16ChunkIterator) Next() bool {
	if cr.currentIndex >= len(cr.chunks) {
		return false
	}

	if cr.currentChunk != nil {
		cr.currentChunk.Release()
	}

	cr.currentChunk = cr.chunks[cr.currentIndex]
	cr.currentChunk.Retain()
	cr.currentIndex++

	return true
}

// Retain keeps a reference to the Float16ChunkIterator
func (cr *Float16ChunkIterator) Retain() {
	atomic.AddInt64(&cr.refCount, 1)
}

// Release removes a reference to the Float16ChunkIterator
func (cr *Float16ChunkIterator) Release() {
	debug.Assert(atomic.LoadInt64(&cr.refCount) > 0, "too many releases")
	ref := atomic.AddInt64(&cr.refCount, -1)
	if ref == 0 {
		cr.col.Release()
		for i := range cr.chunks {
			cr.chunks[i].Release()
		}
		if cr.currentChunk != nil {
			cr.currentChunk.Release()
			cr.currentChunk = nil
		}
		cr.col = nil
		cr.chunks = nil
		cr.dtype = nil
	}
}

// TimestampChunkIterator is an iterator for reading an Arrow Column value by value.
type TimestampChunkIterator struct {
	refCount int64
	col      *array.Column

	// Things Chunked maintains. We're going to maintain it ourselves.
	chunks []*array.Timestamp // cache the chunks on this iterator
	length int64              // this isn't set right on Chunked so we won't rely on it there. Instead we keep the correct value here.
	nulls  int64
	dtype  arrow.DataType

	// Things we need to maintain for the iterator
	currentIndex int              // current chunk
	currentChunk *array.Timestamp // current chunk
}

// NewTimestampChunkIterator creates a new TimestampChunkIterator for reading an Arrow Column.
func NewTimestampChunkIterator(col *array.Column) *TimestampChunkIterator {
	col.Retain()

	// Chunked is not using the correct type to keep track of length so we have to recalculate it.
	columnChunks := col.Data().Chunks()
	chunks := make([]*array.Timestamp, len(columnChunks))
	var length int64
	var nulls int64

	for i, chunk := range columnChunks {
		// Keep our own refs to chunks
		chunks[i] = chunk.(*array.Timestamp)
		// Retain the chunk
		chunks[i].Retain()

		// Keep our own counters instead of Chunked's
		length += int64(chunk.Len())
		nulls += int64(chunk.NullN())
	}

	return &TimestampChunkIterator{
		refCount: 1,
		col:      col,

		chunks: chunks,
		length: length,
		nulls:  nulls,
		dtype:  col.DataType(),

		currentIndex: 0,
		currentChunk: nil,
	}
}

// Chunk will return the current chunk that the iterator is on.
func (cr *TimestampChunkIterator) Chunk() *array.Timestamp { return cr.currentChunk }

// ChunkValues returns the underlying []arrow.Timestamp chunk values.
// Keep in mind the []arrow.Timestamp type might not be able
// to account for nil values. You must check for those explicitly via the chunk.
func (cr *TimestampChunkIterator) ChunkValues() []arrow.Timestamp { return cr.Chunk().TimestampValues() }

// Next moves the iterator to the next chunk. This will return false
// when there are no more chunks.
func (cr *TimestampChunkIterator) Next() bool {
	if cr.currentIndex >= len(cr.chunks) {
		return false
	}

	if cr.currentChunk != nil {
		cr.currentChunk.Release()
	}

	cr.currentChunk = cr.chunks[cr.currentIndex]
	cr.currentChunk.Retain()
	cr.currentIndex++

	return true
}

// Retain keeps a reference to the TimestampChunkIterator
func (cr *TimestampChunkIterator) Retain() {
	atomic.AddInt64(&cr.refCount, 1)
}

// Release removes a reference to the TimestampChunkIterator
func (cr *TimestampChunkIterator) Release() {
	debug.Assert(atomic.LoadInt64(&cr.refCount) > 0, "too many releases")
	ref := atomic.AddInt64(&cr.refCount, -1)
	if ref == 0 {
		cr.col.Release()
		for i := range cr.chunks {
			cr.chunks[i].Release()
		}
		if cr.currentChunk != nil {
			cr.currentChunk.Release()
			cr.currentChunk = nil
		}
		cr.col = nil
		cr.chunks = nil
		cr.dtype = nil
	}
}

// Time32ChunkIterator is an iterator for reading an Arrow Column value by value.
type Time32ChunkIterator struct {
	refCount int64
	col      *array.Column

	// Things Chunked maintains. We're going to maintain it ourselves.
	chunks []*array.Time32 // cache the chunks on this iterator
	length int64           // this isn't set right on Chunked so we won't rely on it there. Instead we keep the correct value here.
	nulls  int64
	dtype  arrow.DataType

	// Things we need to maintain for the iterator
	currentIndex int           // current chunk
	currentChunk *array.Time32 // current chunk
}

// NewTime32ChunkIterator creates a new Time32ChunkIterator for reading an Arrow Column.
func NewTime32ChunkIterator(col *array.Column) *Time32ChunkIterator {
	col.Retain()

	// Chunked is not using the correct type to keep track of length so we have to recalculate it.
	columnChunks := col.Data().Chunks()
	chunks := make([]*array.Time32, len(columnChunks))
	var length int64
	var nulls int64

	for i, chunk := range columnChunks {
		// Keep our own refs to chunks
		chunks[i] = chunk.(*array.Time32)
		// Retain the chunk
		chunks[i].Retain()

		// Keep our own counters instead of Chunked's
		length += int64(chunk.Len())
		nulls += int64(chunk.NullN())
	}

	return &Time32ChunkIterator{
		refCount: 1,
		col:      col,

		chunks: chunks,
		length: length,
		nulls:  nulls,
		dtype:  col.DataType(),

		currentIndex: 0,
		currentChunk: nil,
	}
}

// Chunk will return the current chunk that the iterator is on.
func (cr *Time32ChunkIterator) Chunk() *array.Time32 { return cr.currentChunk }

// ChunkValues returns the underlying []arrow.Time32 chunk values.
// Keep in mind the []arrow.Time32 type might not be able
// to account for nil values. You must check for those explicitly via the chunk.
func (cr *Time32ChunkIterator) ChunkValues() []arrow.Time32 { return cr.Chunk().Time32Values() }

// Next moves the iterator to the next chunk. This will return false
// when there are no more chunks.
func (cr *Time32ChunkIterator) Next() bool {
	if cr.currentIndex >= len(cr.chunks) {
		return false
	}

	if cr.currentChunk != nil {
		cr.currentChunk.Release()
	}

	cr.currentChunk = cr.chunks[cr.currentIndex]
	cr.currentChunk.Retain()
	cr.currentIndex++

	return true
}

// Retain keeps a reference to the Time32ChunkIterator
func (cr *Time32ChunkIterator) Retain() {
	atomic.AddInt64(&cr.refCount, 1)
}

// Release removes a reference to the Time32ChunkIterator
func (cr *Time32ChunkIterator) Release() {
	debug.Assert(atomic.LoadInt64(&cr.refCount) > 0, "too many releases")
	ref := atomic.AddInt64(&cr.refCount, -1)
	if ref == 0 {
		cr.col.Release()
		for i := range cr.chunks {
			cr.chunks[i].Release()
		}
		if cr.currentChunk != nil {
			cr.currentChunk.Release()
			cr.currentChunk = nil
		}
		cr.col = nil
		cr.chunks = nil
		cr.dtype = nil
	}
}

// Time64ChunkIterator is an iterator for reading an Arrow Column value by value.
type Time64ChunkIterator struct {
	refCount int64
	col      *array.Column

	// Things Chunked maintains. We're going to maintain it ourselves.
	chunks []*array.Time64 // cache the chunks on this iterator
	length int64           // this isn't set right on Chunked so we won't rely on it there. Instead we keep the correct value here.
	nulls  int64
	dtype  arrow.DataType

	// Things we need to maintain for the iterator
	currentIndex int           // current chunk
	currentChunk *array.Time64 // current chunk
}

// NewTime64ChunkIterator creates a new Time64ChunkIterator for reading an Arrow Column.
func NewTime64ChunkIterator(col *array.Column) *Time64ChunkIterator {
	col.Retain()

	// Chunked is not using the correct type to keep track of length so we have to recalculate it.
	columnChunks := col.Data().Chunks()
	chunks := make([]*array.Time64, len(columnChunks))
	var length int64
	var nulls int64

	for i, chunk := range columnChunks {
		// Keep our own refs to chunks
		chunks[i] = chunk.(*array.Time64)
		// Retain the chunk
		chunks[i].Retain()

		// Keep our own counters instead of Chunked's
		length += int64(chunk.Len())
		nulls += int64(chunk.NullN())
	}

	return &Time64ChunkIterator{
		refCount: 1,
		col:      col,

		chunks: chunks,
		length: length,
		nulls:  nulls,
		dtype:  col.DataType(),

		currentIndex: 0,
		currentChunk: nil,
	}
}

// Chunk will return the current chunk that the iterator is on.
func (cr *Time64ChunkIterator) Chunk() *array.Time64 { return cr.currentChunk }

// ChunkValues returns the underlying []arrow.Time64 chunk values.
// Keep in mind the []arrow.Time64 type might not be able
// to account for nil values. You must check for those explicitly via the chunk.
func (cr *Time64ChunkIterator) ChunkValues() []arrow.Time64 { return cr.Chunk().Time64Values() }

// Next moves the iterator to the next chunk. This will return false
// when there are no more chunks.
func (cr *Time64ChunkIterator) Next() bool {
	if cr.currentIndex >= len(cr.chunks) {
		return false
	}

	if cr.currentChunk != nil {
		cr.currentChunk.Release()
	}

	cr.currentChunk = cr.chunks[cr.currentIndex]
	cr.currentChunk.Retain()
	cr.currentIndex++

	return true
}

// Retain keeps a reference to the Time64ChunkIterator
func (cr *Time64ChunkIterator) Retain() {
	atomic.AddInt64(&cr.refCount, 1)
}

// Release removes a reference to the Time64ChunkIterator
func (cr *Time64ChunkIterator) Release() {
	debug.Assert(atomic.LoadInt64(&cr.refCount) > 0, "too many releases")
	ref := atomic.AddInt64(&cr.refCount, -1)
	if ref == 0 {
		cr.col.Release()
		for i := range cr.chunks {
			cr.chunks[i].Release()
		}
		if cr.currentChunk != nil {
			cr.currentChunk.Release()
			cr.currentChunk = nil
		}
		cr.col = nil
		cr.chunks = nil
		cr.dtype = nil
	}
}

// Date32ChunkIterator is an iterator for reading an Arrow Column value by value.
type Date32ChunkIterator struct {
	refCount int64
	col      *array.Column

	// Things Chunked maintains. We're going to maintain it ourselves.
	chunks []*array.Date32 // cache the chunks on this iterator
	length int64           // this isn't set right on Chunked so we won't rely on it there. Instead we keep the correct value here.
	nulls  int64
	dtype  arrow.DataType

	// Things we need to maintain for the iterator
	currentIndex int           // current chunk
	currentChunk *array.Date32 // current chunk
}

// NewDate32ChunkIterator creates a new Date32ChunkIterator for reading an Arrow Column.
func NewDate32ChunkIterator(col *array.Column) *Date32ChunkIterator {
	col.Retain()

	// Chunked is not using the correct type to keep track of length so we have to recalculate it.
	columnChunks := col.Data().Chunks()
	chunks := make([]*array.Date32, len(columnChunks))
	var length int64
	var nulls int64

	for i, chunk := range columnChunks {
		// Keep our own refs to chunks
		chunks[i] = chunk.(*array.Date32)
		// Retain the chunk
		chunks[i].Retain()

		// Keep our own counters instead of Chunked's
		length += int64(chunk.Len())
		nulls += int64(chunk.NullN())
	}

	return &Date32ChunkIterator{
		refCount: 1,
		col:      col,

		chunks: chunks,
		length: length,
		nulls:  nulls,
		dtype:  col.DataType(),

		currentIndex: 0,
		currentChunk: nil,
	}
}

// Chunk will return the current chunk that the iterator is on.
func (cr *Date32ChunkIterator) Chunk() *array.Date32 { return cr.currentChunk }

// ChunkValues returns the underlying []arrow.Date32 chunk values.
// Keep in mind the []arrow.Date32 type might not be able
// to account for nil values. You must check for those explicitly via the chunk.
func (cr *Date32ChunkIterator) ChunkValues() []arrow.Date32 { return cr.Chunk().Date32Values() }

// Next moves the iterator to the next chunk. This will return false
// when there are no more chunks.
func (cr *Date32ChunkIterator) Next() bool {
	if cr.currentIndex >= len(cr.chunks) {
		return false
	}

	if cr.currentChunk != nil {
		cr.currentChunk.Release()
	}

	cr.currentChunk = cr.chunks[cr.currentIndex]
	cr.currentChunk.Retain()
	cr.currentIndex++

	return true
}

// Retain keeps a reference to the Date32ChunkIterator
func (cr *Date32ChunkIterator) Retain() {
	atomic.AddInt64(&cr.refCount, 1)
}

// Release removes a reference to the Date32ChunkIterator
func (cr *Date32ChunkIterator) Release() {
	debug.Assert(atomic.LoadInt64(&cr.refCount) > 0, "too many releases")
	ref := atomic.AddInt64(&cr.refCount, -1)
	if ref == 0 {
		cr.col.Release()
		for i := range cr.chunks {
			cr.chunks[i].Release()
		}
		if cr.currentChunk != nil {
			cr.currentChunk.Release()
			cr.currentChunk = nil
		}
		cr.col = nil
		cr.chunks = nil
		cr.dtype = nil
	}
}

// Date64ChunkIterator is an iterator for reading an Arrow Column value by value.
type Date64ChunkIterator struct {
	refCount int64
	col      *array.Column

	// Things Chunked maintains. We're going to maintain it ourselves.
	chunks []*array.Date64 // cache the chunks on this iterator
	length int64           // this isn't set right on Chunked so we won't rely on it there. Instead we keep the correct value here.
	nulls  int64
	dtype  arrow.DataType

	// Things we need to maintain for the iterator
	currentIndex int           // current chunk
	currentChunk *array.Date64 // current chunk
}

// NewDate64ChunkIterator creates a new Date64ChunkIterator for reading an Arrow Column.
func NewDate64ChunkIterator(col *array.Column) *Date64ChunkIterator {
	col.Retain()

	// Chunked is not using the correct type to keep track of length so we have to recalculate it.
	columnChunks := col.Data().Chunks()
	chunks := make([]*array.Date64, len(columnChunks))
	var length int64
	var nulls int64

	for i, chunk := range columnChunks {
		// Keep our own refs to chunks
		chunks[i] = chunk.(*array.Date64)
		// Retain the chunk
		chunks[i].Retain()

		// Keep our own counters instead of Chunked's
		length += int64(chunk.Len())
		nulls += int64(chunk.NullN())
	}

	return &Date64ChunkIterator{
		refCount: 1,
		col:      col,

		chunks: chunks,
		length: length,
		nulls:  nulls,
		dtype:  col.DataType(),

		currentIndex: 0,
		currentChunk: nil,
	}
}

// Chunk will return the current chunk that the iterator is on.
func (cr *Date64ChunkIterator) Chunk() *array.Date64 { return cr.currentChunk }

// ChunkValues returns the underlying []arrow.Date64 chunk values.
// Keep in mind the []arrow.Date64 type might not be able
// to account for nil values. You must check for those explicitly via the chunk.
func (cr *Date64ChunkIterator) ChunkValues() []arrow.Date64 { return cr.Chunk().Date64Values() }

// Next moves the iterator to the next chunk. This will return false
// when there are no more chunks.
func (cr *Date64ChunkIterator) Next() bool {
	if cr.currentIndex >= len(cr.chunks) {
		return false
	}

	if cr.currentChunk != nil {
		cr.currentChunk.Release()
	}

	cr.currentChunk = cr.chunks[cr.currentIndex]
	cr.currentChunk.Retain()
	cr.currentIndex++

	return true
}

// Retain keeps a reference to the Date64ChunkIterator
func (cr *Date64ChunkIterator) Retain() {
	atomic.AddInt64(&cr.refCount, 1)
}

// Release removes a reference to the Date64ChunkIterator
func (cr *Date64ChunkIterator) Release() {
	debug.Assert(atomic.LoadInt64(&cr.refCount) > 0, "too many releases")
	ref := atomic.AddInt64(&cr.refCount, -1)
	if ref == 0 {
		cr.col.Release()
		for i := range cr.chunks {
			cr.chunks[i].Release()
		}
		if cr.currentChunk != nil {
			cr.currentChunk.Release()
			cr.currentChunk = nil
		}
		cr.col = nil
		cr.chunks = nil
		cr.dtype = nil
	}
}

// MonthIntervalChunkIterator is an iterator for reading an Arrow Column value by value.
type MonthIntervalChunkIterator struct {
	refCount int64
	col      *array.Column

	// Things Chunked maintains. We're going to maintain it ourselves.
	chunks []*array.MonthInterval // cache the chunks on this iterator
	length int64                  // this isn't set right on Chunked so we won't rely on it there. Instead we keep the correct value here.
	nulls  int64
	dtype  arrow.DataType

	// Things we need to maintain for the iterator
	currentIndex int                  // current chunk
	currentChunk *array.MonthInterval // current chunk
}

// NewMonthIntervalChunkIterator creates a new MonthIntervalChunkIterator for reading an Arrow Column.
func NewMonthIntervalChunkIterator(col *array.Column) *MonthIntervalChunkIterator {
	col.Retain()

	// Chunked is not using the correct type to keep track of length so we have to recalculate it.
	columnChunks := col.Data().Chunks()
	chunks := make([]*array.MonthInterval, len(columnChunks))
	var length int64
	var nulls int64

	for i, chunk := range columnChunks {
		// Keep our own refs to chunks
		chunks[i] = chunk.(*array.MonthInterval)
		// Retain the chunk
		chunks[i].Retain()

		// Keep our own counters instead of Chunked's
		length += int64(chunk.Len())
		nulls += int64(chunk.NullN())
	}

	return &MonthIntervalChunkIterator{
		refCount: 1,
		col:      col,

		chunks: chunks,
		length: length,
		nulls:  nulls,
		dtype:  col.DataType(),

		currentIndex: 0,
		currentChunk: nil,
	}
}

// Chunk will return the current chunk that the iterator is on.
func (cr *MonthIntervalChunkIterator) Chunk() *array.MonthInterval { return cr.currentChunk }

// ChunkValues returns the underlying []arrow.MonthInterval chunk values.
// Keep in mind the []arrow.MonthInterval type might not be able
// to account for nil values. You must check for those explicitly via the chunk.
func (cr *MonthIntervalChunkIterator) ChunkValues() []arrow.MonthInterval {
	return cr.Chunk().MonthIntervalValues()
}

// Next moves the iterator to the next chunk. This will return false
// when there are no more chunks.
func (cr *MonthIntervalChunkIterator) Next() bool {
	if cr.currentIndex >= len(cr.chunks) {
		return false
	}

	if cr.currentChunk != nil {
		cr.currentChunk.Release()
	}

	cr.currentChunk = cr.chunks[cr.currentIndex]
	cr.currentChunk.Retain()
	cr.currentIndex++

	return true
}

// Retain keeps a reference to the MonthIntervalChunkIterator
func (cr *MonthIntervalChunkIterator) Retain() {
	atomic.AddInt64(&cr.refCount, 1)
}

// Release removes a reference to the MonthIntervalChunkIterator
func (cr *MonthIntervalChunkIterator) Release() {
	debug.Assert(atomic.LoadInt64(&cr.refCount) > 0, "too many releases")
	ref := atomic.AddInt64(&cr.refCount, -1)
	if ref == 0 {
		cr.col.Release()
		for i := range cr.chunks {
			cr.chunks[i].Release()
		}
		if cr.currentChunk != nil {
			cr.currentChunk.Release()
			cr.currentChunk = nil
		}
		cr.col = nil
		cr.chunks = nil
		cr.dtype = nil
	}
}

// DayTimeIntervalChunkIterator is an iterator for reading an Arrow Column value by value.
type DayTimeIntervalChunkIterator struct {
	refCount int64
	col      *array.Column

	// Things Chunked maintains. We're going to maintain it ourselves.
	chunks []*array.DayTimeInterval // cache the chunks on this iterator
	length int64                    // this isn't set right on Chunked so we won't rely on it there. Instead we keep the correct value here.
	nulls  int64
	dtype  arrow.DataType

	// Things we need to maintain for the iterator
	currentIndex int                    // current chunk
	currentChunk *array.DayTimeInterval // current chunk
}

// NewDayTimeIntervalChunkIterator creates a new DayTimeIntervalChunkIterator for reading an Arrow Column.
func NewDayTimeIntervalChunkIterator(col *array.Column) *DayTimeIntervalChunkIterator {
	col.Retain()

	// Chunked is not using the correct type to keep track of length so we have to recalculate it.
	columnChunks := col.Data().Chunks()
	chunks := make([]*array.DayTimeInterval, len(columnChunks))
	var length int64
	var nulls int64

	for i, chunk := range columnChunks {
		// Keep our own refs to chunks
		chunks[i] = chunk.(*array.DayTimeInterval)
		// Retain the chunk
		chunks[i].Retain()

		// Keep our own counters instead of Chunked's
		length += int64(chunk.Len())
		nulls += int64(chunk.NullN())
	}

	return &DayTimeIntervalChunkIterator{
		refCount: 1,
		col:      col,

		chunks: chunks,
		length: length,
		nulls:  nulls,
		dtype:  col.DataType(),

		currentIndex: 0,
		currentChunk: nil,
	}
}

// Chunk will return the current chunk that the iterator is on.
func (cr *DayTimeIntervalChunkIterator) Chunk() *array.DayTimeInterval { return cr.currentChunk }

// ChunkValues returns the underlying []arrow.DayTimeInterval chunk values.
// Keep in mind the []arrow.DayTimeInterval type might not be able
// to account for nil values. You must check for those explicitly via the chunk.
func (cr *DayTimeIntervalChunkIterator) ChunkValues() []arrow.DayTimeInterval {
	return cr.Chunk().DayTimeIntervalValues()
}

// Next moves the iterator to the next chunk. This will return false
// when there are no more chunks.
func (cr *DayTimeIntervalChunkIterator) Next() bool {
	if cr.currentIndex >= len(cr.chunks) {
		return false
	}

	if cr.currentChunk != nil {
		cr.currentChunk.Release()
	}

	cr.currentChunk = cr.chunks[cr.currentIndex]
	cr.currentChunk.Retain()
	cr.currentIndex++

	return true
}

// Retain keeps a reference to the DayTimeIntervalChunkIterator
func (cr *DayTimeIntervalChunkIterator) Retain() {
	atomic.AddInt64(&cr.refCount, 1)
}

// Release removes a reference to the DayTimeIntervalChunkIterator
func (cr *DayTimeIntervalChunkIterator) Release() {
	debug.Assert(atomic.LoadInt64(&cr.refCount) > 0, "too many releases")
	ref := atomic.AddInt64(&cr.refCount, -1)
	if ref == 0 {
		cr.col.Release()
		for i := range cr.chunks {
			cr.chunks[i].Release()
		}
		if cr.currentChunk != nil {
			cr.currentChunk.Release()
			cr.currentChunk = nil
		}
		cr.col = nil
		cr.chunks = nil
		cr.dtype = nil
	}
}
